[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GG3209 - Spatial Analysis with GIS",
    "section": "",
    "text": "About this site\nThis book has been developed as part of the module GG3209 ‚Äì Spatial Analysis with GIS at the School of Geography and Sustainable Development, University of St Andrews. This module is spitted in two parts, the first 4 weeks includes QGIS and Multi-criteria evaluation, the second part related to the use of Python for the use and analysis of spatial data.\nThis part will establish a comprehensive introduction to Python (an easy-to-learn and powerful programming language) and its use for manipulating spatial data and deploying spatial analysis models. Python has been cataloged as one of the most popular programming technologies and is widely used as a scripting language in the GIScience world. If you have signed to this module you will learn how to use Python in multiple environments, more specifically using a popular tool called Jupyter Notebooks, then learn how to manipulate vector and raster data and finish by integrating spatial modelling using coding environments and clustering methods as helpful methodologies for dissertations.\nThis module include Lecture+Lab sessions. Lectures will be delivered first, followed by lab practices included in this site. Students will be expected to work on these during the lab sessions but may also have to continue their own for the rest of the week, since the scheduled time may not be sufficient to finish everything.\nAll students enrolled in GG3209 have access to the University‚Äôs ArcGIS Online Organisational Account using their University credentials. We will use this platform in some of the Labs. If you havent experimenting and working with this platform before, to get started, please log in at: üëâ https://uostandrews.maps.arcgis.com\n\n\nVideo\nSign In to ArcGIS Online St Andrews"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n1 + 1\n\n[1] 2\n\n\n\n\n\n\nKnuth, Donald E. 1984. ‚ÄúLiterate Programming.‚Äù Comput. J. 27 (2): 97‚Äì111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "gg3209_install_guide.html",
    "href": "gg3209_install_guide.html",
    "title": "Python Environment Installation",
    "section": "",
    "text": "Additional Resources\nUse the following instructions as a guide for extra resources and better familiarity with working with Python. In case you want to manage your python environment, export your outcomes to PDF, and get extra learning resources."
  },
  {
    "objectID": "gg3209_install_guide.html#table-of-contents",
    "href": "gg3209_install_guide.html#table-of-contents",
    "title": "Python Environment Installation",
    "section": "Table of Contents",
    "text": "Table of Contents\n\nPrerequisites\nInstalling Anaconda/Miniconda\nCreating the Environment\nVerifying Installation\nRunning Jupyter Lab\nCommon Issues and Solutions\nEnvironment Management\nAdditional Resources"
  },
  {
    "objectID": "gg3209_install_guide.html#prerequisites",
    "href": "gg3209_install_guide.html#prerequisites",
    "title": "Python Environment Installation",
    "section": "Prerequisites",
    "text": "Prerequisites\nBefore starting, ensure you have:\n\nA stable internet connection (large downloads required)\nAt least 5GB of free disk space\nAdministrator privileges on your computer\nBasic familiarity with command line interface (we will have a show demo about this during the lectures)\n\nIf you don‚Äôt know how to validate this, please make an appointment with out IT service who can support you with this gsditsupport@st-andrews.ac.uk"
  },
  {
    "objectID": "gg3209_install_guide.html#installing-miniconda-required-for-all-students",
    "href": "gg3209_install_guide.html#installing-miniconda-required-for-all-students",
    "title": "Python Environment Installation",
    "section": "Installing Miniconda (Required for All Students)",
    "text": "Installing Miniconda (Required for All Students)\nWhy Miniconda? Miniconda provides a clean, minimal Python installation with only essential packages. This ensures all students start with identical environments and reduces potential conflicts. It‚Äôs lightweight, fast, and gives us complete control over installed packages.\n\nWindows Installation\n\nDownload Miniconda:\n\nVisit https://docs.conda.io/en/latest/miniconda.html\nDownload ‚ÄúMiniconda3 Windows 64-bit‚Äù (approximately 50MB)\nImportant: Download the Python 3.10 version specifically\n\nInstall Miniconda:\n\nDouble-click the downloaded .exe file\nClick ‚ÄúNext‚Äù through the installation wizard\nCRITICAL: When asked about PATH, select ‚ÄúAdd Miniconda3 to my PATH environment variable‚Äù\nAccept all other default settings\nComplete installation (takes 2-3 minutes)\n\nVerify Installation:\n\nOpen Command Prompt (Press Win + R, type cmd, press Enter)\nType conda --version and press Enter\nYou should see: conda 23.x.x (or similar version number)\nType python --version and press Enter\nYou should see: Python 3.10.x\n\n\n\n\nmacOS Installation\n\nDownload Miniconda:\n\nVisit https://docs.conda.io/en/latest/miniconda.html\nFor Apple Silicon Macs (M1/M2): Download ‚ÄúMiniconda3 macOS Apple M1 64-bit pkg‚Äù\nFor Intel Macs: Download ‚ÄúMiniconda3 macOS Intel x86 64-bit pkg‚Äù\nImportant: Download the Python 3.10 version specifically\n\nInstall Miniconda:\n\nDouble-click the downloaded .pkg file\nFollow the installation wizard\nAccept all default settings\nComplete installation\n\nVerify Installation:\n\nOpen Terminal (Press Cmd + Space, type ‚ÄúTerminal‚Äù, press Enter)\nType conda --version and press Enter\nYou should see: conda 23.x.x (or similar version number)\nType python --version and press Enter\nYou should see: Python 3.10.x\n\n\n\n\nPost-Installation Setup (All Students)\nAfter successful installation, run these commands to ensure consistency:\n# Update conda to latest version\nconda update -n base -c defaults conda\n\n# Configure conda for optimal performance\nconda config --set auto_activate_base false\nconda config --add channels conda-forge\nconda config --set channel_priority strict\n\n# Verify configuration\nconda info\nExpected Output: You should see conda-forge listed as a channel with highest priority."
  },
  {
    "objectID": "gg3209_install_guide.html#creating-the-environment",
    "href": "gg3209_install_guide.html#creating-the-environment",
    "title": "Python Environment Installation",
    "section": "Creating the Environment",
    "text": "Creating the Environment\n\nStep 1: Download the Environment File\nSave the environment configuration as environment.yml in a folder of your choice (e.g., Documents/gg3209/).\n\n\nStep 2: Open Command Line Interface\nAll students must use the correct command line interface to ensure consistency.\n\nWindows Students\n\nPress Win + R, type cmd, press Enter\nAlternative: Search for ‚ÄúCommand Prompt‚Äù in Start Menu\nImportant: Use Command Prompt, NOT PowerShell or other terminals\n\n\n\nmacOS Students\n\nPress Cmd + Space, type ‚ÄúTerminal‚Äù, press Enter\nAlternative: Go to Applications &gt; Utilities &gt; Terminal\nImportant: Use Terminal, NOT other command line apps\n\n\n\n\nStep 3: Navigate to Your Project Directory\nAll students should create the same folder structure:\n# Windows students\nmkdir C:\\gg3209 #sds stands for spatial dtata science \ncd C:\\gg3209\n\n# macOS students\nmkdir ~/gg3209\ncd ~/gg3209\n\n\nStep 4: Download and Verify Environment File\nBefore creating the environment, ensure you have the correct file:\n\nSave the environment.yml file in your project directory. This file is located in Moodle, go there and download it and place it in the project directory you created earlier.\nVerify the file exists:\n\n# All students run this command\ndir environment.yml    # Windows\nls environment.yml     # macOS\nYou should see the file listed. If not, ensure you saved it correctly.\n\n\nStep 5: Create the Environment (Critical Step)\nThis is where consistency matters most. All students run the exact same commands:\n# Create environment from file\nconda env create -f environment.yml\n\n# This will take 15-30 minutes\n# You will see many packages being downloaded and installed\n# Wait for \"done\" message before proceeding\nExpected Output:\nCollecting package metadata (repodata.json): done\nSolving environment: done\nPreparing transaction: done\nVerifying transaction: done\nExecuting transaction: done\n#\n# To activate this environment, use\n#\n#     $ conda activate spatial-data-science\n#\n# To deactivate an active environment, use\n#\n#     $ conda deactivate\n\n\nStep 6: Activate the Environment\nAll students must activate the environment before using it ‚Äì THIS IS VERY IMPORTANT:\n# Activate the environment\nconda activate gg3209\nSuccess Indicator: Your command prompt should now show (gg3209) at the beginning:\n# Windows example\n(gg3209) C:\\gg3209&gt;\n\n# macOS example\n(gg3209) username@computer:~/gg3209$\n\n\nStep 7: Final Verification\nAll students run the same verification script:\nOnce you have created your python environment, now it is important you test that everything is properly installed. Using the same terminal or command prompt window run the following command.\n# Make sure your environment is activated\nconda activate gg3209\n\n# Run the test\npython test_installation.py\n\n------\n# Windows example\n(gg3209) C:\\gg3209\\&gt; python verification_script.py\n\n# macOS example\n(gg3209) username@computer:~/gg3209/$ python verification_script.py\nExpected Output for All Students:\nPython version: 3.10.x\nPython location: [path to conda environment]\n‚úì All required libraries imported successfully!\n‚úì Environment setup is complete and consistent!\n‚úì GeoPandas version: 1.1.1\n‚úì Pandas version: 2.3.1\n‚úì NumPy version: 1.26.4\nIf successful, you should see version numbers and check-marks."
  },
  {
    "objectID": "gg3209_install_guide.html#running-jupyter-lab",
    "href": "gg3209_install_guide.html#running-jupyter-lab",
    "title": "Python Environment Installation",
    "section": "Running Jupyter Lab",
    "text": "Running Jupyter Lab\n\nStarting Jupyter Lab\n# Make sure environment is activated (optional if you know you have activated it)\nconda activate gg3209\n\n# Make sure you are in your project directory e.g. GG3209\n\ncd GG3209\n\n# Launch Jupyter Lab\njupyter lab\nThis will:\n- Start the Jupyter server\n- Open your default web browser\n- Display the Jupyter Lab interface\n\n\nCreating Your First Notebook\n\nClick ‚ÄúPython 3 (ipykernel)‚Äù under ‚ÄúNotebook‚Äù\nTest with a simple spatial analysis:\n\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nimport geodatasets\n\n# Create a simple test\nworld = gpd.read_file(geodatasets.get_path(\"naturalearth.land\"))\nworld.plot(figsize=(10, 6))\nplt.title('World Map Test')\nplt.show()\n\n\nStopping Jupyter Lab\n\nIn your browser: File &gt; Shut Down\nIn command line: Press Ctrl + C (Windows) or Cmd + C (Mac)"
  },
  {
    "objectID": "gg3209_install_guide.html#gg3209-specific-setup-instructions",
    "href": "gg3209_install_guide.html#gg3209-specific-setup-instructions",
    "title": "Python Environment Installation",
    "section": "GG3209-Specific Setup Instructions",
    "text": "GG3209-Specific Setup Instructions\n\nFirst Day of Class Checklist\nAll students must complete before first lab:\n\nInstall Miniconda (Python 3.10)\nCreate spatial-data-science environment\nActivate environment successfully\nRun verification script (must pass)\nStart Jupyter Lab (must open in browser)\nCreate test notebook with basic spatial analysis\n\n\n\nWeekly Environment Check\nRun this command weekly to ensure consistency:\npython -c \"\nimport geopandas as gpd\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport folium\nfrom esda.getisord import G_Local\nfrom sklearn.cluster import DBSCAN\nprint('‚úì Environment is working correctly')\nprint(f'‚úì GeoPandas version: {gpd.__version__}')\nprint(f'‚úì Pandas version: {pd.__version__}')\n\"\n\n\nSubmission Requirements\nFor all assignments, include this environment information:\n# Add this cell at the top of every notebook\nimport sys\nimport geopandas as gpd\nimport pandas as pd\n\nprint(f\"Python version: {sys.version}\")\nprint(f\"GeoPandas version: {gpd.__version__}\")\nprint(f\"Pandas version: {pd.__version__}\")\nprint(f\"Environment: gg3209\")\nThis ensures all students are working with identical software versions and helps instructors debug issues consistently."
  },
  {
    "objectID": "gg3209_install_guide.html#next-steps",
    "href": "gg3209_install_guide.html#next-steps",
    "title": "Python Environment Installation",
    "section": "Next Steps",
    "text": "Next Steps\nOnce your environment is set up:\n\nComplete the verification tests\nTry the sample notebook\nExplore the example datasets\nBegin your spatial analysis project\n\nYour spatial data science environment for the course GG3209 is now ready for the first Labs, this part as complicated as it seems now will allow you to create and practice all your python skills."
  },
  {
    "objectID": "gg3209_install_guide.html#common-issues-and-solutions",
    "href": "gg3209_install_guide.html#common-issues-and-solutions",
    "title": "Python Environment Installation",
    "section": "Troubleshooting Guide",
    "text": "Troubleshooting Guide\nWith Python and in particular with many new ways to use your computer, create folder and scripts things can get messy and very confusing, this is very normal and it is part of the process. The first thing is do not get frustrated or trying all sort of things without understanding what is the root of the issue. S you need to think systematically and then find out the solution. Here I have listed a few potential and common issues you might find. So first take all of this before escalating your issue to the lecturer or the IT support team.\n\nBefore Seeking Help\nAll students should complete this checklist:\n\nMiniconda is installed and conda --version works\nEnvironment was created without errors\nEnvironment shows (gg3209) when activated\nVerification script runs successfully\nJupyter Lab starts without errors\n\n\n\nClass Support Protocol\n\nFirst: Check this troubleshooting guide\nSecond: Ask a classmate (compare outputs)\nThird: Post your issue in the MS Teams channel of this course:\n\nYour operating system (Windows/macOS)\nExact error message\nCommands you ran\nOutput from verification script\n\n\n\n\nStandardized Error Reporting\nWhen reporting problems, always include:\n# Run these commands and include output\nconda info\nconda list geopandas\npython --version\njupyter --version\n\n\n\nIssue 1: ‚Äúconda: command not found‚Äù\nThis is the most common issue for beginners.\nWindows Solution:\n# Option 1: Use the correct command prompt\n# Search for \"Anaconda Prompt\" in Start Menu if available\n# Or reinstall Miniconda ensuring PATH is added\n\n# Option 2: Manually add to PATH\nset PATH=%PATH%;C:\\Users\\%USERNAME%\\miniconda3\\Scripts\nset PATH=%PATH%;C:\\Users\\%USERNAME%\\miniconda3\nmacOS Solution:\n# Add to PATH temporarily\nexport PATH=\"$HOME/miniconda3/bin:$PATH\"\n\n# Add to PATH permanently\necho 'export PATH=\"$HOME/miniconda3/bin:$PATH\"' &gt;&gt; ~/.bash_profile\nsource ~/.bash_profile\n\n# For zsh users (macOS Catalina and later)\necho 'export PATH=\"$HOME/miniconda3/bin:$PATH\"' &gt;&gt; ~/.zshrc\nsource ~/.zshrc\n\n\nIssue 2: Environment Creation Fails\nCommon causes and solutions:\n# Solution 1: Clean conda cache\nconda clean --all\n\n# Solution 2: Update conda first\nconda update conda\n\n# Solution 3: Try creating environment with explicit solver\nconda env create -f environment.yml --solver=classic\n\n# Solution 4: Check internet connection and try again\n# Large downloads may timeout on slow connections\n\n\nIssue 3: Different Python Versions\nAll students must have Python 3.10 for consistency.\n# Check your Python version\npython --version\n\n# If incorrect, remove environment and recreate\nconda env remove --name gg3209\nconda env create -f environment.yml\n\n\nIssue 4: Package Conflicts During Installation\nThis indicates environment file issues:\n# Solution: Use mamba for faster, more reliable solving\nconda install mamba -n base -c conda-forge\nmamba env create -f environment.yml\n\n\nIssue 5: Jupyter Lab Won‚Äôt Start\nConsistency check:\n# Ensure environment is activated\nconda activate gg3209\n\n# Verify Jupyter installation\njupyter --version\n\n# If missing, reinstall\nconda install jupyter jupyterlab -c conda-forge\n\n# Start Jupyter Lab\njupyter lab\n\n\nIssue 6: Import Errors Despite Successful Installation\nEnvironment activation problem:\n# Always activate environment first\nconda activate gg3209\n\n# Check which Python you're using\nwhich python     # macOS/Linux\nwhere python     # Windows\n\n# Should show path to conda environment, not system Python\n\n\nIssue 7: PDF Generation Not Working\nLaTeX installation issues:\n# Verify LaTeX installation\npdflatex --version\n\n# If missing, install manually:\n# Windows: Download MiKTeX from https://miktex.org/\n# macOS: Install MacTeX from https://tug.org/mactex/\n\n# Test PDF conversion\njupyter nbconvert --to pdf test_notebook.ipynb\n\n\nEmergency Reinstallation\nIf all else fails, complete clean installation:\n# Remove environment\nconda env remove --name gg3209\n\n# Clean all caches\nconda clean --all\n\n# Recreate environment\nconda env create -f environment.yml"
  },
  {
    "objectID": "gg3209_install_guide.html#pdf-generation",
    "href": "gg3209_install_guide.html#pdf-generation",
    "title": "Python Environment Installation",
    "section": "PDF Generation",
    "text": "PDF Generation\nYou are required to submit your work as report to MMS in a PDF format, and most of the outcomes created in this modules are Jupyter Notebooks, so you will need to export them as PDF. This environment includes comprehensive PDF generation capabilities for creating professional scientific documents from Jupyter notebooks. This includes:\n\nLaTeX-based PDF generation for high-quality academic formatting\nWeb-based PDF conversion for quick exports\nScientific document formatting with proper citations and references\nProfessional layout templates for reports and dissertations\n\n\nTesting PDF Generation\nAfter setting up your environment, test the PDF generation capabilities:\n\nOpen a terminal or command prompt windows and lunch python.\nlocate a folder where you can create a python script.\nCreate the\n\nimport nbformat\nfrom nbconvert import PDFExporter\nimport os\n\nprint(\"Testing PDF generation capabilities...\")\n\n# Test LaTeX availability\ntry:\n    import subprocess\n    result = subprocess.run(['pdflatex', '--version'], \n                          capture_output=True, text=True)\n    if result.returncode == 0:\n        print(\"‚úì LaTeX/PDFLaTeX is available\")\n    else:\n        print(\"‚úó LaTeX not found\")\nexcept:\n    print(\"‚úó LaTeX not available\")\n\n# Test nbconvert PDF export\ntry:\n    exporter = PDFExporter()\n    print(\"‚úì nbconvert PDF exporter is available\")\nexcept Exception as e:\n    print(f\"‚úó nbconvert PDF exporter error: {e}\")\n\n# Test WeasyPrint (alternative PDF generator)\ntry:\n    import weasyprint\n    print(\"‚úì WeasyPrint is available\")\nexcept Exception as e:\n    print(f\"‚úó WeasyPrint error: {e}\")\n\n# Test ReportLab (programmatic PDF creation)\ntry:\n    from reportlab.pdfgen import canvas\n    print(\"‚úì ReportLab is available\")\nexcept Exception as e:\n    print(f\"‚úó ReportLab error: {e}\")\n\nprint(\"PDF generation test complete!\")\n\n\nConverting Notebooks to PDF\n\nMethod 1: Command Line (Recommended)\n# Activate environment\nconda activate gg3209\n\n# Convert notebook to PDF via LaTeX\njupyter nbconvert --to pdf your_notebook.ipynb\n\n# Convert with custom template, optional\njupyter nbconvert --to pdf --template classic your_notebook.ipynb\n\n# Convert with bibliography support, optional.\njupyter nbconvert --to pdf --template article your_notebook.ipynb\n\n\nMethod 2: Jupyter Lab Interface\n\nOpen your notebook in Jupyter Lab\nGo to File &gt; Export Notebook As &gt; PDF\nChoose export options\nSave the generated PDF\n\n\n\nMethod 3: Programmatic Conversion (optional)\nimport nbformat\nfrom nbconvert import PDFExporter\n\n# Read notebook\nwith open('your_notebook.ipynb', 'r') as f:\n    nb = nbformat.read(f, as_version=4)\n\n# Convert to PDF\npdf_exporter = PDFExporter()\npdf_exporter.template_name = 'classic'\n(body, resources) = pdf_exporter.from_notebook_node(nb)\n\n# Save PDF\nwith open('output.pdf', 'wb') as f:\n    f.write(body)\n\n\n\nProfessional PDF Features\n\n\nCreating Professional Reports\n\nTemplate Structure\nTo create a template notebook with:\n# Report template structure\n\"\"\"\n# Title: Professional Spatial Data Science Report\n## Author: Your Name\n## Date: Current Date\n## Abstract\nBrief description of the analysis...\n\n## 1. Introduction\nResearch question and objectives...\n\n## 2. Methodology\n### 2.1 Data Sources\n### 2.2 Analytical Methods\n### 2.3 Software and Tools\n\n## 3. Results\n### 3.1 Descriptive Statistics\n### 3.2 Spatial Analysis\n### 3.3 Hotspot Analysis\n\n## 4. Discussion\nInterpretation of results...\n\n## 5. Conclusions\nSummary and recommendations...\n\n## References\nAcademic citations...\n\n## Appendices\nAdditional materials...\n\"\"\"\n\n\nProfessional Visualization for PDF\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Configure matplotlib for high-quality PDF output\nplt.rcParams['figure.dpi'] = 300\nplt.rcParams['savefig.dpi'] = 300\nplt.rcParams['font.size'] = 12\nplt.rcParams['axes.titlesize'] = 14\nplt.rcParams['axes.labelsize'] = 12\nplt.rcParams['xtick.labelsize'] = 10\nplt.rcParams['ytick.labelsize'] = 10\nplt.rcParams['legend.fontsize'] = 11\nplt.rcParams['figure.titlesize'] = 16\n\n# Use professional color palette\nsns.set_palette(\"husl\")\n\n# Create publication-ready figures\nfig, ax = plt.subplots(figsize=(8, 6))\n# Your plotting code here\nplt.tight_layout()\nplt.savefig('figure.png', dpi=300, bbox_inches='tight')\nplt.show()\n\n\n\nTroubleshooting PDF Generation\n\nCommon Issues and Solutions\nIssue: LaTeX not found\n# Solution: Install LaTeX distribution\n# Windows: Download MiKTeX or TeX Live\n# macOS: Install MacTeX\nconda install texlive-core texlive-latex-extra\nIssue: PDF conversion fails\n# Solution: Use alternative method\njupyter nbconvert --to html your_notebook.ipynb\n# Then use browser to print to PDF\nIssue: Figures not appearing in PDF\n# Solution: Ensure figures are saved inline\n%matplotlib inline\nimport matplotlib.pyplot as plt\nplt.rcParams['savefig.format'] = 'png'\nplt.rcParams['savefig.bbox'] = 'tight'\nIssue: Long code cells breaking across pages\n# Solution: Use page breaks and cell splitting\nfrom IPython.display import display, HTML\ndisplay(HTML('&lt;div style=\"page-break-before: always;\"&gt;&lt;/div&gt;'))\n\n\n\nBest Practices for PDF Generation\n\nUse consistent formatting throughout your notebook\nInclude descriptive markdown for each analysis step\nAdd figure captions and table descriptions. One of the most common issue when you create a PDF.\nUse appropriate figure sizes for print media\nTest PDF generation regularly during development\nInclude proper citations and references\nUse professional fonts and color schemes\nOptimize images for print quality (optional)"
  },
  {
    "objectID": "gg3209_install_guide.html#and-more-resources",
    "href": "gg3209_install_guide.html#and-more-resources",
    "title": "Python Environment Installation",
    "section": "And more resources",
    "text": "And more resources\n\nLearning Materials\n\nGeopandas Documentation: https://geopandas.org/\nPySAL Documentation: https://pysal.org/\nSpatial Data Science Book: https://geographicdata.science/book/\n\n\n\nData Sources\n\nNatural Earth: https://www.naturalearthdata.com/\nOpenStreetMap: https://www.openstreetmap.org/\nCensus Data: https://www.census.gov/\n\n\n\nCommunity Support\n\nStack Overflow: Use tags geopandas, spatial-analysis, python\nGitHub Issues: For specific library problems\nReddit: r/gis and r/Python communities\n\n\nLast updated: July 2025, For questions or issues, please refer to the troubleshooting guide"
  },
  {
    "objectID": "Lab_1.html#overview",
    "href": "Lab_1.html#overview",
    "title": "Lab No 1: Intro to Python",
    "section": "Overview",
    "text": "Overview\nWelcome to the second part of the module of GG3209 Spatial Analysis with GIS. This part will take advantage of the initial part, which provided you with a solid understanding of spatial data formats (vector-raster) and use them to perform multiple types of analysis like the so-called Multi-Criteria Evaluation (MCE) using the widely popular Open-Source GIS tool, QGIS.\nNow, in this part, you will be guided to handle and use another powerful tool in the geospatial field, Python. It is a free and open-sourced scripting language that was commonly used to automate tasks in the GIS world. Nowadays, it is one of the most popular programming languages[1], especially in GIScience. It is widely used in the private and public sectors and academia for cutting-edge research, where scripts are created and shared using this language to share new methods, knowledge, data, and analysis through multiple scientific fields.\nIn fact, most companies or institutes where you might want to apply will be happily interested in your development skills using Python and will validate your current contribution or work in platforms like GitHub, where you can share and disseminate your coding project. Think about its impact as we cluster R for spatial statistical analysis, and Python is mainly used for escalable and robust spatial analysis. Every day, more packages[2] and code repositories are shared and maintained for easy use and installation, allowing developers or analysts from all backgrounds and expertise to use and integrate them into their own code.\nThis part of the module and this lab workbook are meant to be an introduction to Python. As with any new language, you need to learn the basic rules (grammar) to write your own script, and then, with practice and more practice, you will soon become a Python developer.\n[1] https://www.stackscale.com/blog/most-popular-programming-languages/\n[2] https://pypi.org/\n\nDo not be afraid of failure or errors, even during the installation process; it has happened to all of us, regardless of the level of expertise or number of projects created. In programming, failure is part of the process; what is essential is to find the foundation of any issue and understand how code, logic, and syntax work in harmony to get the results you are expecting.\n\nEstimated time of completion: 45 Minutes"
  },
  {
    "objectID": "Lab_1.html#learning-outcomes",
    "href": "Lab_1.html#learning-outcomes",
    "title": "Lab No 1: Intro to Python",
    "section": "Learning Outcomes",
    "text": "Learning Outcomes\n\nRun Python scripts using ArcGIS Pro and ArcGIS Online\nConducted xgeoprocessing tasks (e.g., buffering, proximity analysis)\nCreated and saved notebooks and web maps\nPracticed using both ArcPy and ArcGIS Python API\n\n\n\n\n\n\n¬© SGSD | University of St Andrews | GG3209 Spatial Analysis - Introduction to Python"
  },
  {
    "objectID": "Lab_2.html#introduction",
    "href": "Lab_2.html#introduction",
    "title": "Lab No 2: Python Basics - Part 1",
    "section": "Introduction",
    "text": "Introduction\nNow you have acquired some basic skills of creating new notebooks, run your python environment, the next step and certainty the long process is to learn the python basics of this programming language. This will give you an idea of the ‚Äògrammar‚Äô that python includes.\nPlease go to each cell and address the challenges/questions when is required."
  },
  {
    "objectID": "Lab_2.html#content",
    "href": "Lab_2.html#content",
    "title": "Lab No 2: Python Basics - Part 1",
    "section": "Content:",
    "text": "Content:\n\nHow to deal with variables.\nExplain the difference between Python data types.\nPerform mathematical and logical operations.\nWork with lists, tuples, sets, and dictionaries.\nApply appropriate methods to different data types.\n\nIf you need more information or examples, here it is a great resource w3school.com."
  },
  {
    "objectID": "Lab_2.html#variables",
    "href": "Lab_2.html#variables",
    "title": "Lab No 2: Python Basics - Part 1",
    "section": "Variables",
    "text": "Variables\nYou can think of a Variable as anything that related to information or data. A Variable can be a file path on your local machine, could be also a path to a shapefile, could be just a number or letter. Once you create a variable you are assigning a certain space of memory on your computer to storage that information. So you could use it or call it to reference the associated data or object for use in processes and analyses. Note that there are some rules for variable names:\nThere are certain considerations:\n\ncannot start with a number or special character (or, can only start with a letter or an underscore) (for example, x1 is valid while 1x is not.).\ncan only contain letters, numbers, or underscores. No other special characters are allowed (for example, x, x1, _x, and x1_ are all valid. x$ is not valid.).\nare case-sensitive (for example, x1 and X1 are two separate variables).\n\nSince Python is an object-based language, you will primarily interact with your data using variables. The print() function is used to print the data referenced by the variable.\nx = 1\ny = \"Python\"\nx1 = 2\ny1 = \"Spatial Data\"\n_x = 3\n_y = \"Web GIS\"\nprint(x)\nprint(y)\nprint(x1)\nprint(y1)\nprint(_x)\nprint(_y)\nYou can also assign data to multiple variables as a single line of code as demonstrated below. In Python variable names are dynamic, so you can overwrite them. This can, however, be problematic if you overwrite a variable name accidentally. So, use unique names if you do not want to overwrite prior variable.\nx, x1, _x = 1, 2, 3\nprint(x)\nprint(x1)\nprint(_x)\nAssignment Operators are used to assign values or data to variables. The most commonly used operator is =. However, there are some other options that allow variables to be manipulated mathematically with the resulting value saved back to the original data object that the variable references. These additional assignment operators can be useful, but you will use the = operator most of the time.\nFor example, += will add a value to the current value and assign the result back to the original variable. In the first example below, x references the value 2. The += assignment operator is then used to add 3 to x and save the result back to x. Work through the provided examples and make sure you understand the use of each operator.\nx = 2\nprint(x)\nx += 3\nprint(x)\n\nx = 2\nprint(x)\nx -= 3\nprint(x)\n\nx = 2\nprint(x)\nx *= 3\nprint(x)\n\nx = 2\nprint(x)\nx /= 3\nprint(x)\n\nx = 2\nprint(x)\nx **= 3\nprint(x)\n\nImportant Note:\nIn the cell bellow, you will run small experiment that explains some important behavior of Python. You have defined a variable a that holds a list of three values. We will discuss lists later in this section. Now, you create a new variable b and assign it to be equal to a. Layer you edit the variable a by appending a new value to the list (You will see how this is done later, so don‚Äôt worry if you don‚Äôt understand how this works yet). When you print a and b, you can see that both variables contain the same set of numbers in the list even though you added 8 to a after setting b equal to a. Or, the change that you made to a was also applied to b.\nIn Python, certain types of objects, such as lists, are mutable. This means that it is possible to change the data stored in memory and referenced to the variable. When a mutable object is altered, all variables that point to it will reflect this change. What this means practically is that setting b equal to a results in a and b pointing to the same object or data in memory. So, changes to a or b will be reflected in both variables since the data being referenced by both have been updated.\nIf you have experience in R, and I guess you do, you will see how Python is different, as in R, setting a variable equal to another variable would make a copy that was not linked and could be altered without changing the original variable.\nTo test whether two variables reference the same object in memory, you can use the is keyword. if True is returned, then they reference the same object. You can also print the object ID, which represents the memory address for the object, using the id() function. Using both methods below, you can see that a and b reference the same object.\na = [5, 6, 7]\nb = a\na.append(8)\nprint(a)\nprint(b)\n\nprint(a is b)\nprint(id(a))\nprint(id(b))\nWhat if you wanted to make a copy of a variable referencing mutable data that does not reference the same object?\nFor example, you may want to be able to make changes to a that do not impact b. This can be accomplished using the copy() or deepcopy() functions from the copy module.\nCheck how now we import a new package, module or library to get new functionalities.\nIn the experiment below, You have defined b as a deep copy of a. Now, changes made to a do not impact b. This is because they do not reference the same object in memory since deepcopy() makes a copy of the object or data to a new location in memory. This is confirmed using is and id().\nimport copy\na = [5, 6, 7]\nb = copy.deepcopy(a)\na.append(8)\nprint(a)\nprint(b)\n\nprint(a is b)\nprint(id(a))\nprint(id(b))"
  },
  {
    "objectID": "Lab_2.html#comments-important-for-clear-and-scalable-coding",
    "href": "Lab_2.html#comments-important-for-clear-and-scalable-coding",
    "title": "Lab No 2: Python Basics - Part 1",
    "section": "Comments (Important for clear and scalable coding)",
    "text": "Comments (Important for clear and scalable coding)\nNow please pay attention as this is the key of many developers and analysts, you need to learn how to commenting your code. Comments are used to make your code more readable and are not interpreted by the computer. Instead, they are skipped and meant for humans. Different languages use different syntax to denote comments. Python uses the hashtag or pound sign. You can add comments as new lines or following code on the same line.\nUnfortunately, Python does not have specific syntax for multi-line comments. However, this can be accomplished by adding hashtags before each separate line or using a multi-line string that is not assigned to a variable. Examples are shown below.\nIt is generally a good idea to comment your code for later use and for use by others. In fact you need to comment your code for all assignments and exercises you run in this part of the course.\n#Single-line comment\nx = 1\ny = 2 #Another single-line comment\n#A\n#multi-line\n#comment\nz = 3\n\"\"\"\nAnother multi-line comment\n\"\"\"\nw = 4"
  },
  {
    "objectID": "Lab_2.html#data-types",
    "href": "Lab_2.html#data-types",
    "title": "Lab No 2: Python Basics - Part 1",
    "section": "Data Types",
    "text": "Data Types\nA variety of data types are available in Python to store and work with a variety of input. Below are explanations of the data types which you will use most often. There are additional types that we will not discuss.\nWhen creating a variable, it is not generally necessary to explicitly define the data type. However, this can be accomplished using constructor functions if so desired. Constructor functions can also be used to change the data type of a variable, a process known as casting.\nAvailable constructor methods include str(), int(), float(), complex(), list(), tuple(), dict(), set(), and bool().\nTo determine the data type, you can use the type() function. See the examples below where I convert an integer to a float and then a float to a string.\n\nNumeric\n\nInt = whole numbers\nFloat = numbers with decimal values\nComplex = can include imaginary numbers\n\nText\n\nString = characters or numbers treated as characters\n\nBoolean\n\nBoolean = logical True or False\n\nSequence\n\nList = list of features that can be re-ordered, allows for duplicates, and is indexed\nTuple = list of features that cannot be re-ordered, allows for duplicates, and is indexed\n\nMapping\n\nDictionary = list of features that can be re-ordered, does not allow duplicates, is indexed, and contains key and value pairs\n\nSet\n\nSet = list of features that are unordered, not indexed, and does not allow for duplicates\n\n\n#Create a variable and check the data type\nx = 1\nprint(type(x))\n#Change the data type\nx = float(x)\nprint(type(x))\nx= str(x)\nprint(type(x))\n\nNumbers\nRegardless of the the type (integer, float, or complex), numbers are defined without using quotes. If a number is placed in quotes it will be treated as a string as demonstrated below. This is important, since the behavior of the data is altered. In the example, x represents 1 as a number while y represents ‚Äú1‚Äù as a string (note the quotes). Adding x to itself will yield 2 (1 + 1). Adding y to itself will yield ‚Äú11‚Äù, or the two strings are combined or concatenated.\n#Create variables\nx = 1\ny = \"1\"\nprint(x + x)\nprint(y + y)\nNumbers support mathematical operations, as demonstrated below. If you are not familiar with these concepts, modulus will return the remainder after division while floor division will round down to the nearest whole number after division.\nIf a whole number has no decimal values included or no period (1 vs.¬†1. or 1.0), this implies that the output is in the integer data type as opposed to float type.\nx = 4\ny = 3\nprint(x + y) #Addition\nprint(x - y) #Subtraction\nprint(x * y) #Multiplication\nprint(x / y) #Division\nprint(x % y) #Modulus\nprint(x ** y) #Exponentiation\nprint(x // y) #Floor Division\n\n\nStrings\nStrings are defined using single or double quotes. If quotes are included as part of the text or string, then you can use the other type to define the data as text. Again, numbers placed in quotes will be treated as strings.\nx = \"Python\"\ny = \"is great\" #Must use double quotes since a single quote is use in the string\nz = \"2\" #Number treated as a string\nprint (x,y,z)\nPortions of a string can be sliced out using indexes.\nVery important note: In Python the indexing starts at 0 as opposed to 1., like in R So, the first character is at index 0 as opposed to index 1. Negative indexes can be used to index relative to the end of the string. In this case, the last character has an index of -1.\nIndexes combined with square brackets can be used to slice strings. Note that the last index specified in the selection or range will not be included and that spaces are counted in the indexing.\nx = \"GG3209 Spatial Analysis with GIS\"\nprint(x[0:6])\nprint(x[7:14])\nprint(x[15:23])\nprint(x[-3:])\nStrings can be combined or concatenated using the addition sign. If you want to include a number in the string output, you can cast it to a string using str(). In the example below, note the use of blank spaces so that the strings are not ran together.\nThe len() function can be used to return the length of the string, which will count blank spaces along with characters.\nx = \"Spatial\"\nxx=\"GG\"\ny = 3209\nz = \"Analysis\"\nw = \"With Python\"\nstrng1 = xx + str(y) + \" \"+ x + \" \" + z + \" \" + w\nprint(strng1)\nprint(len(strng1))\n\n\nMethod\nA method is a function that belongs to or is associated with an object. Or, it allows you to work with or manipulate the object and its associated properties in some way. Data types have default methods that can be applied to them.\nMethods applicable to strings are demonstrated below. Specifically, methods are being used to change the case and split the string at each space to save each component to a list.\nx = \"GG3209 Spatial Analysis with GIS\"\nprint(x.upper())\nprint(x.lower())\nlst1 = x.split(\" \")\nprint(lst1)\nWhen generating strings, issues arise when you use characters that have special uses or meaning in Python. These issues can be alleviated by including an escape character or backslash as demonstrated below.\ns1 = \"Issue with \\\"quotes\\\" in the string.\"\ns2 = \"C:\\\\data\\\\project_1\" #Issue with file paths. \ns3 = \"Add a new line \\nto text string\"\nprint(s1)\nprint(s2)\nprint(s3)\n\n\nBooleans\nBooleans can only be True or False and are often returned when an expression is logically evaluated.\nA variety of comparison operators are available. Note the use of double equals; a single equals cannot be used since it is already used for variable assignment, or is an assignment operator, and would thus be ambiguous.\n\nComparison Operators\n\nEqual: ==\nNot Equal: !=\nGreater Than: &gt;\nGreater Than or Equal To: &gt;=\nLess Than: &lt;\nLess Than or Equal To: &lt;=\n\n\nLogical statements or multiple expressions can be combined using Logical Operators.\n\nLogical Operators:\n\nA AND B: and\nA OR B: or\nA NOT B: not\n\n\nx = 3\ny = 7\nz = 2\nprint(x == 7)\nprint(x &gt; y)\nprint(x &lt; y)\n\nprint(x &lt; y and x &gt; z)\nprint(x &lt; y and x &lt; z)\nprint(x &lt; y or x &lt; z)\nYou can also assign Booleans to a variable. Note that you do not use quotes, as that would cause the text to be treated as a string instead of a Boolean.\nx = \"True\"\ny = True\nprint(type(x))\nprint(type(y))\n\n\nLists\nNow one of the very relevant type of objects in Python. Lists allow you to store multiple numbers, strings, or Booleans in a single variable. Square brackets are used to denote lists.\nItems in a list are ordered, indexed, and allow for duplicate members. Indexing starts at 0. If counting from the end, you start at -1 and subtract as you move left. A colon can be used to denote a range of indexes, and an empty argument before the colon indicates to select all elements up to the element following the colon while an empty argument after the colon indicates to select the element at the index specified before the colon and all features up to the end of the list. The element at the last index is not included in the selection.\nPython lists can contain elements of different data types.\nlst1 = [6, 7, 8, 9, 11, 2, 0]\nlst2 = [\"A\", \"B\", \"C\", \"D\", \"E\"]\nlst3 = [True, False, True, True, True, False]\nprint(lst1[0])\nprint(lst1[0:3])\nprint(lst2[-4:-1])\nprint(lst2[:3])\nprint(lst2[3:])\nlst4 = [1, 2, \"A\", \"B\", True]\nprint(type(lst4[0]))\nprint(type(lst4[2]))\nprint(type(lst4[4]))\nWhen the len() function is applied to a list, it will return the number of items or elements in the list as opposed to the number of characters. When applied to a string item in a list, this function will return the length of the string.\nlst1 = [\"A\", \"B\", \"C\", \"D\", \"E\"]\nprint(len(lst1))\nprint(len(lst1[0]))\nThe code below shows some example methods for strings.\nlst1 = [\"A\", \"B\", \"C\", \"D\", \"E\"]\nlst1.append(\"F\") #Add item to list\nprint(lst1)\nlst1.remove(\"F\") #Remove item from a list\nprint(lst1) \nlst1.insert(2, \"ADD\") #Add item to list at defined position \nprint(lst1)\nlst1.pop(2) #Remove item at specified index or the last item if no index is provided\nprint(lst1)\nAs explained above, in order to copy a list and not just reference the original data object, you must use the copy() or deepcopy() method. Simply setting a new variable equal to the original list will cause it to reference the original data object, so changes made to the old list will update to the new list. This is demonstrated in the example below.\nlst1 = [\"A\", \"B\", \"C\", \"D\", \"E\"]\nlst2 = lst1\nlst3 = lst1.copy()\nprint(lst2)\nprint(lst3)\nlst1.append(\"F\")\nprint(lst2)\nprint(lst3)\nLists can be concatenated together, or a list can be appended to another list, using the methods demonstrated below.\nlst1 = [\"A\", \"B\", \"C\"]\nlst2 = [\"D\", \"E\", \"F\"]\nlst3 = lst1 + lst2\nprint(lst1)\nprint(lst2)\nprint(lst3)\nlst1.extend(lst2)\nprint(lst1)\nLastly, lists can contain other lists, tuples, or dictionaries, which will be discussed below. In the example, lst2 contains four elements, the last of which is a list with three elements.\nlst1 = [\"A\", \"B\", \"C\"]\nlst2 = [\"D\", \"E\", \"F\", lst1]\nprint(lst2)\n\n\nTuples\nTuples are similar to lists in that they are ordered and allow duplicate elements. However, they cannot be altered by adding items, removing items, or changing the order of items. To differentiate them from lists, parenthesis are used as opposed to square brackets. Think of tuples as lists that are protected from alteration, so you could use them when you want to make sure you don‚Äôt accidentally make changes.\nIf you need to change a tuple, it can be converted to a list, manipulated, then converted back to a tuple.\nt1 = (1, 3, 4, 7)\nprint(type(t1))\n\n\nDictionaries (not the one for spelling)\nDictionaries are unordered, changeable, indexed, and do not allow for duplicate elements. In contrast to lists, tuples, each value is also assigned a key.\nAnd here is the key ‚Äì&gt; Values can be selected using the associated key.\nYou can also use the key to define a value to change.\nSimilar to lists, you must use the copy() or deepcopy() method to obtain a copy of the dictionary that will not reference the original data or memory object.\ncls = {\"code\": \"GG3209\", \"Name\":\"Spatial Analysis with Python\" }\nprint(cls)\nprint(cls[\"Name\"])\ncls[\"Code\"] = 461\nprint(cls)\nMultiple dictionaries can be combined into a nested dictionary, as demonstrated below.\nThe keys can then be used to extract a sub-dictionary or an individual element from a sub-dictionary.\ncls1 = {\"prefix\" : \"GG\", \"Number\" : 3209, \"Name\": \"Spatial Analysis with Python\"}\ncls2 = {\"prefix\" : \"GG\", \"Number\" : 3210, \"Name\": \"Advanced Analysis with Python\"}\ncls3 = {\"prefix\" : \"GG\", \"Number\" : 3211, \"Name\": \"Introduction to Remote Sensing\"}\ncls4 = {\"prefix\" : \"GG\", \"Number\" : 3212, \"Name\": \"Web GIS\"}\nclsT = {\n    \"class1\" : cls1,\n    \"class2\" : cls2,\n    \"class3\" : cls3,\n    \"class4\" : cls4\n}\nprint(clsT)\nprint(clsT[\"class1\"])\nprint(clsT[\"class1\"][\"Name\"])"
  },
  {
    "objectID": "Lab_2.html#additional-types",
    "href": "Lab_2.html#additional-types",
    "title": "Lab No 2: Python Basics - Part 1",
    "section": "Additional Types",
    "text": "Additional Types\n\nArrays\nArrays are similar to lists; however, they must be declared.\nThey are sometimes used in place of lists as they can be very compact and easy to apply mathematical operations. However in this course, we will primarily work with NumPy arrays, which will be discussed in more detail in a later module.\nIf you wanna know how an array looks like, here is an example\nmy_array = [1, 2, 3, 4, 5]\nprint(my_array[0])   # Output: 1\nprint(my_array[2])   # Output: 3\nYou can also modify elements in the array by assigning a new value to a specific index:\nmy_array[1] = 7\nprint(my_array)      # Output: [1, 7, 3, 4, 5]\n\n\nClasses\nNow some a more complex type of object in Python: Classes are used to define specific types of objects in Python and are often described as templates.\nOnce a class is defined, it can be copied and manipulated to create a subclass, which will inherit properties and methods from the parent class but can be altered for specific uses. You get more details in the next Notebook (Part 2). You will also see example uses of classes in futher examples.\nOne use of classes is to define specialized data models and their associated methods and properties. For example, classes have been defined to work with geospatial data types.\nclass Dog:\n    def __init__(self, name, breed):\n        self.name = name\n        self.breed = breed\n    \n    def bark(self):\n        print(\"Woof!\")\n\nmy_dog = Dog(\"Buddy\", \"Golden Retriever\")\nprint(my_dog.name)    # Output: Buddy\nprint(my_dog.breed)   # Output: Golden Retriever\nmy_dog.bark()         # Output: Woof!\nIn the example above, we‚Äôve defined a class called Dog that has a constructor method ‚Äúinit that takes two parameters, name and breed.\nInside the constructor, we assign the passed-in values to instance (re-create the object) variables with the same names using the self keyword.\nWe‚Äôve also defined a method called bark that simply prints out ‚ÄúWoof!‚Äù when called. To call this method on an instance of the Dog class, we first create an instance of the class by calling the constructor and passing in the required parameters, and then we call the bark method on that instance.\n\n\nFinal remarks\nBefore moving on, I wanted to note which data types are mutable and which are immutable.\nAgain, data or objects that are mutable can be altered after they are defined (such as adding a new element to a list).\nMutable types include lists, sets, and dictionaries.\nImmutable types include booleans, integers, float, complex, strings, and tuples.\n\n\nNext Step\nOnce you finish this, now clone Python_Basics_Part2, In that notebook, we will discuss more components of Python including functions, control flow, loops, modules, and reading data from disk."
  },
  {
    "objectID": "Lab_2.html#references",
    "href": "Lab_2.html#references",
    "title": "Lab No 2: Python Basics - Part 1",
    "section": "References",
    "text": "References\n\nPythonGIS\nPython Data Spatial"
  },
  {
    "objectID": "Lab_3.html#introduction",
    "href": "Lab_3.html#introduction",
    "title": "Lab No 3: Python Basics - Part 2",
    "section": "Introduction",
    "text": "Introduction\nWe will now discuss additional components of the Python language including functions, flow control, loops, modules, and reading/writing data from disk. It is important you learn effective ways to make your code efficient, as python can be memory-consuming, but at the same time learn how to create Loops, and flow control will help to run tasks in an automatic ways making your scripts a powerful tool.\nIf you have some experience with this type of conditions or components from your previous courses with R, you will see that the logic is the same. Reading and writing files using python is also a key skill to learn, as in most of the cases you will need to access files, or folders where your spatial data is located.\nPlease go through every cell, reading carefully all descriptions and run the code cell to see the examples, you later might want to use this notebook to recall how to create the following components:\n\nContent\n\nDefine and use functions.\nUse If‚Ä¶Else statements, While Loops, and For Loops.\nDescribe and interpret classes and methods.\nAccess and use modules and libraries.\nWork with local files and directories.\nUse f-strings and list comprehension.\n\nIf you need more information or examples Here it is a great resource w3school.com."
  },
  {
    "objectID": "Lab_3.html#functions",
    "href": "Lab_3.html#functions",
    "title": "Lab No 3: Python Basics - Part 2",
    "section": "2. Functions",
    "text": "2. Functions\nFunctions are probably one of the key components in any programming language, Functions do something when called. You can think of those as tools. Methods, which we will discuss in more detail later in this notebook, are like functions except that they are tied to a specific object.\nWhen creating a new class, you can define methods specific to the new class. Functions generally have the following generic syntax:\noutput = function(Parameter1, Parameter2). #Think of parameters as Inputs., so you have output = function(Input1, Input2)\nIn contrast, methods will have the following generic syntax:\noutput = object.method(Parameter1, Parameter2).  \nBelow, You are generating a simple function that multiplies two numbers together.\nThe def keyword is used when defining a function. Within the parenthesis, a list of parameters, which are often specific inputs or required settings, can be provided.\nIn the below example, the function accepts two parameters: *a* and *b*. On the next line, indented, and after the colon, what the function does is defined. In this case, the function simply returns the product of the two values. The **return** keyword is used to define the output of the function (or what is returned), in this case the product of the two provided values.\nOnce a function is created, it can be used. In Example 1, You will see two arguments, or values assigned to the parameters, and save the result to a variable x.\nThen when using a function, it is also possible to provide the arguments as key and value pairs, as in Example 2.\nWhen creating a function, default arguments can be provided for parameters when the function is defined. If arguments are not provided when the function is used, then the default values will be used, as demonstrated in Example 3.\n\n2.1 Indentation\nThis is a good time to stop and describe indentation.\nPython makes use of whitespace, indentations, or tabs to denote or interpret units of code. This is uncommon, as most other languages use brackets or punctuation of some kind. So, it is important to properly use indentations or your code will fail to execute correctly or at all.\n#Example 1\ndef multab(a,b):\n    return a*b\n\nx = multab(3,6)\nprint(x)\n\n#Example 2\nx = multab(a=5, b=3)\nprint(x)\n\n#Example 3\ndef multab(a=1,b=1):\n    return a*b\nx = multab()\nprint(x)\n\n\nChallenge 2.1\n\nIn the next code cell, create a function that transform the distance in miles to kilometers between London and Edinburgh. Try no to google or use ChatGPT for this challenge, as those will provide more advance suggestion, you will only need the previous cell description to run this challenge.\n\n\n\n2.2 Options *args and **kwargs for functions\nThere are a few other options when defining functions that increase flexibility. For example, what if you wanted to edit the function created above so that it can accept more than two arguments and so that the number of arguments can vary? This can be accomplished using either *args or **kwargs.\n*args:\nA single asterisk (*) is used to unpack an iterable, such as a list, whereas two asterisks (**) are used to unpack a dictionary. Using *args allows you to to provide a variable number of non-keyword arguments (or, each argument does not need to be assigned a key). In contrast, **kwargs is used to provide a variable number of keyword arguments (or, each argument must have a key).\nIn the first example below, You altered the function from above to accept two or more arguments.\nWithin the function, later you define a variable x1 that initially assigned a value of 1. Then, inside of a for loop, which will be discussed later, you iteratively multiply x1 by the next provided value. To test the function, a feed it the values 1 through 5 as non-keyword arguments.\nThe result is calculated as 1x1 ‚Äì&gt; 1x2 ‚Äì&gt; 2x3 ‚Äì&gt; 6x4 ‚Äì&gt; 24x5 ‚Äì&gt; 120.\nNote that the single asterisk is key here. The work ‚Äúargs‚Äù could be replaced with another term, as the second part of the example demonstrates. What is important is that * is used to unpack an iterable.\n# Example 1\n\ndef multab(*args):\n    x1 = 1\n    for a in args:\n        x1 *= a\n    return x1\n\nx = multab(1, 2, 3, 4, 5)\nprint(x) \n\n#Example 2\n\ndef multab(*nums):\n    x1 = 1\n    for a in nums:\n        x1 *= a\n    return x1\n\nx = multab(1, 2, 3, 4, 5)\nprint(x) \n**kwargs:\nThe next example demonstrates the use of **kwargs. Here, the arguments must have keys. Again, what is important here is the use of ** to unpack a dictionary: ‚Äúkwargs‚Äù can be replaced with another term. Note the use of the .values() method for a dictionary. This allows access to the values as opposed to the associated keys.\ndef multab(**kwargs):\n    x1 = 1\n    for a in kwargs.values():\n        x1 *= a\n    return x1\n\nx = multab(a=1, b=2, c=3, d=4, e=5)\nprint(x)\n\ndef multab(**nums):\n    x1 = 1\n    for a in nums.values():\n        x1 *= a\n    return x1\n\nx = multab(a=1, b=2, c=3, d=4, e=5)\nprint(x)\nThe next cell demonstrates the use of the single asterisk to unpack an iterable, in this case a list. Each element in the list is returned separately as opposed to as a single list object. This is the same functionality implemented by *args.\nx = [2,3,4,5]\nprint(*x)\nLastly, it is possible to use both *args and **kwargs in the same function.#\nHowever, *args must be provided before **kwargs. In the example below, the parameter a is provided an argument of 1 while the parameter b is provided an argument of 2. 3 would be associated with *args, since it is not assigned a key, while 4 and 5 would be associated with **kwargs since they are assigned a key.\n# Create a function\ndef multab(a=2, b=2, *args, **kwargs):\n    x1 = 1 #Define variables\n    x1 *= a\n    x1 *= b\n    if args: # Conditional\n        for arg in args: #Loop\n            x1 *= arg\n    if kwargs:\n        for kwarg in kwargs.values():\n            x1 *= kwarg\n    return x1\n\nx = multab(1, 2, 3, c=3, d=4)\nprint(x)\n# Read description below to understand how this function works, looks more complicated than actually it is.\nAs the examples above demonstrate, *args and **kwargs increase the flexibility of functions in Python by allowing for variable numbers of arguments. Even if you do not make use of these options, they are important to understand, as many functions that you encounter will make use of them. So, knowledge of this functionality will aid you in understanding how to implement specific functions and interpret the associated documentation.\n\nNOTE:\nThe following options will you give an additional level of skill in Python. Although they are rarely included in python basics, we consider that if you can master those, you will have an extra level of expertise and will definitely help you to make more efficient programs using python.\n\n\n\n2.3 Lambda\nA lambda function is a special function case that is generally used for simple functions that can be anonymous or not named. They can accepted multiple arguments but can only include one expression. Lambda functions are commonly used inside of other functions.\nlam1 = lambda a, b, c: str(a) + \" \" + str(b) + \" \" + str(c)\nprint(lam1(\"Geospatial\", \"Data\", \"Science\"))\n\na = \"Geospatial\"\nb = \"Dasta\"\nc = \"Science\"\n\n\n2. Scope\nVariables are said to have global scope if they can be accessed anywhere in the code.\nIn contrast, local scope implies that variables are only accessible in portions of the code.\nFor example, by default new variables defined within a function cannot be called or used outside of the function. If you need to specify a variable within a function as having global scope, the global keyword can be used.\nIn the first example below, the variables xG, yG, and z have global scope, so can be called and used outside of the function. In contrast, variables xL and yL have local scope and are not available outside of the function. If you attempt to run the last line of code, which is commented out, you will get an error.\nxG = 2\nyG = 3\ndef Func1(a, b):\n    xL = a*a\n    yL = b*b\n    return xL + yL\n\nz = Func1(xG, yG)\nprint(xG)\nprint(z)\n#print(xL+3) will not work due to local scope\nIf you need a variable declared inside of a function to have global scope, you can use the global keyword as demonstrated below.\nxG = 2\nyG = 3\ndef Func1(a, b):\n    global xL \n    xL = a*a\n    global yL \n    yL = b*b\n    return xL + yL\n\nz = Func1(xG, yG)\nprint(xG)\nprint(z)\nprint(xL+3)\n\n\n3. Pass\nIt is not possible to leave a function empty when it is defined. As you develop code, you can make use of the pass keyword as a placeholder before adding content to a function. This will allow you to work with your code without errors until you complete the content within the function. pass can also be used within incomplete class definitions and loops.\ndef multab(x, y):\n    pass"
  },
  {
    "objectID": "Lab_3.html#conditionals---control-flow",
    "href": "Lab_3.html#conditionals---control-flow",
    "title": "Lab No 3: Python Basics - Part 2",
    "section": "Conditionals - Control Flow",
    "text": "Conditionals - Control Flow\n\n1. If‚Ä¶Else\nAll coding languages allow for control flow in which different code is executed depending on a condition.\nIf‚Ä¶Else statements are a key component of how this is implemented. Using logical conditions that evaluate to True or False, it is possible to program different outcomes. Think about this as the rules, if something is True, then do this, but if something is False, then do that.\nThe first example uses only if. So, if the condition evaluates to True, the remaining code will be executed. If it evaluates to False then nothing is executed or returned. In this case, the condition evaluates to True, so the text is printed.\nAgain, remember that indentation is very important in Python. The content of the if statement must be indented or the code will fail.\nx = 7\nif x &gt; 6:\n    print(str(x) + \" is greater than 6.\")\nIt is common to have a default statement that is executed if the condition evaluates to False as opposed to simply doing nothing. This is the use of an else statement. No condition is required for the else statement since it will be executed for any case where the if condition evaluates to False. Again, note the required indentation.\nx = 3\nif x &gt; 6:\n    print(str(x) + \" is greater than 6.\")\nelse:\n    print(str(x) + \" is less than or equal to 6.\")\nWhat if you want to evaluate against more than one condition? This can be accomplished by incorporating one or multiple elif statements. The code associated with the else statement will only be executed if the if and all elif statements evaluate to False.\nAll statements should be mutually exclusive or non-overlapping so that the logic is clear. In the second example, I have changed the first condition to x &gt;= 6, so now the condition in the if and elif statements overlap. When the code is executed, the result from the if statement is returned. Since the first condition evaluated to True, the associated code was executed and the elif and else statements were ignored. If I swap the if and elif conditions, a different result is obtained. So, the order matters. In short, this ambiguity can be avoided by using conditions that are mutually exclusive and non-overlapping.\nx = 6\nif x &gt; 6:\n    print(str(x) + \" is greater than 6.\")\nelif x == 6:\n     print(str(x) + \" is equal to 6.\")\nelse:\n    print(str(x) + \" is less than 6.\")\nx = 6\nif x &gt;= 6:\n    print(str(x) + \" is greater than 6.\")\nelif x == 6:\n     print(str(x) + \" is equal to 6.\")\nelse:\n    print(str(x) + \" is less than 6.\")\n\n\nx = 6\nif x == 6:\n     print(str(x) + \" is equal to 6.\")\nelif x &gt;= 6:\n     print(str(x) + \" is greater than 6.\")\nelse:\n    print(str(x) + \" is less than 6.\")\n\n\n2. While Loop\nWhile loops are used to loop code as long as a condition evaluates to True. In the example below, a variable i is initially set to 14.\nThe loop executes as long as i remains larger than 7. At the end of each loop the -= assignment operator is used to subtract 1 from i. Also, i is simply a variable, so you do not need to use i specifically. For example, i could be replaced with x.\nPlease consider the following, One potential issue with a while loop is the possibility of an infinite loop in which the loop never stops because the condition never evaluates to False. For example, if I change the assignment operator to +=, the condition will continue to evaluate to True indefinitely.\ni = 14\nwhile i &gt; 7:\n    print(i)\n    i -= 1\n\n\n3. For Loop\nFor Loops will execute code for all items in a sequence. For loops make use of data types that are iterable, or that can return each individual element in the data object sequentially (for example, each string element in a list). Data types that are iterable include lists, tuples, strings, dictionaries, and sets.\nIn the first example below, a for loop is being used to print every value in a list. In the next example, each character in a string is printed sequentially. Both lists and strings are iterable, so can be looped over.\nlst1 = [3, 6, 8, 9, 11, 13]\nfor i in lst1:\n    print(\"Value is: \" + str(i))\nstr1 = \"Remote Sensing\"\nfor c in str1:\n    print(c)\nCombining a for loop and If‚Ä¶Else statements allows for different code to be executed for each element in a sequence or iterable, such as a list, based on conditions, as demonstrated in the code below. In later modules, you will see example use cases for working with and analyzing spatial data. Note the levels of indentation used, which, again, are very important and required when coding in Python. The content in the for loop is indented with one tab while the content within the if, elif, and else statements, which are include in the for loop, are indented with two tabs.\nlst1 = [3, 6, 8, 9, 11, 13]\nfor i in lst1:\n    if i &lt; 8:\n        print(str(i) + \" is less than 8.\")\n    elif i == 8:\n        print(str(i) + \" is equal to 8.\")\n    else:\n        print(str(i) + \" is greater than 8.\")\nThe range() function is commonly used in combination with for loops. Specifically, it is used to define an index for each element in an iterable that can then be used within the loop.\nIn the example below, range() is used to define indices for all elements in a list. The len() function returns the length, so the returned indices will be 0 through the length of the list, in this case 4. The for loop will iterate over indices 0 through 3 (the last index is not included). This allows for the index to be used within the loop. In the example, the index is used to extract each element from the list and save it to a new local variable (country), which is then provided to a print statement.\ncountries = [\"Belgium\", \"Mexico\", \"Italy\", \"India\"]\nfor i in range(len(countries)):\n    country = countries[i]\n    print(\"I would like to visit \" + country + \".\")\nAnother function that is commonly used in combination with for loops is enumerate(). For each element in the iterable, enumerate() will return an index and the element. Both can then be used within the loop.\nIn the first example below, enumerate() is used to create an index and extract each element in the list sequentially. In this case, the enumeration is not necessary, since the index is not needed. However, in the next example, the index is used to print different results depending on whether the index is even or odd. So, enumerate() is needed because I need access to both the index and the data element within the loop.\ncountries = [\"Belgium\", \"Mexico\", \"Italy\", \"India\"]\nfor index, country in enumerate(countries):\n    print(\"I would like to visit \" + country + \".\")\ncountries = [\"Belgium\", \"Mexico\", \"Italy\", \"India\"]\nfor index, country in enumerate(countries):\n    if index%2 == 0:\n        print(\"I would like to visit \" + country + \".\")\n    else:\n        print(\"I would not like to visit \" + country + \".\")\nThere are some other useful techniques for flow control, code development, and error handling that we will not discuss in detail here. For example, try, except, and finally can be used to to handle errors and provide error messages. break is used to terminate a for loop based on a condition. continue can be used to skip the remaining steps in an iteration and move on to the next iteration in a loop."
  },
  {
    "objectID": "Lab_3.html#list-comprehension---great-feature-from-python",
    "href": "Lab_3.html#list-comprehension---great-feature-from-python",
    "title": "Lab No 3: Python Basics - Part 2",
    "section": "List Comprehension - Great Feature from Python!",
    "text": "List Comprehension - Great Feature from Python!\nList comprehension is a nice feature in Python.\nThis technique allows you to create a new list from elements in an existing list and offers more concise syntax than accomplishing the same task using a for loop.\nIn the first example, You will see that we use a list comprehension to return each element (c) in lst1 to a new lst, lst2, if the string starts with the letter ‚ÄúB‚Äù. Here is how you would read the syntax within the square brackets:\n\n‚ÄúReturn the element (c) from the list (lst1) if its first character is‚ÄùB‚Äù.\n\nIn the second example, no condition is used. Instead, you are concatenating ‚ÄúI would like to visit‚Äù to each country and returning each result as an element in a new list.\nYou will see examples of list comprehension in later modules. It is a very handy technique.\n# Example 1\n\nlst1 = [\"Belgium\", \"Mexico\", \"Italy\", \"India\", \"Bulgaria\", \"Belarus\"]\nlst2 = [c for c in lst1 if c[0] == \"B\"]\nprint(lst2)\n# Example 2\n\nlst1 = [\"Belgium\", \"Mexico\", \"Italy\", \"India\", \"Bulgaria\", \"Belarus\"]\nlst2 = [\"I would like to visit \" + c for c in lst1]\nprint(lst2)"
  },
  {
    "objectID": "Lab_3.html#classes",
    "href": "Lab_3.html#classes",
    "title": "Lab No 3: Python Basics - Part 2",
    "section": "Classes",
    "text": "Classes\nWe briefly covered classes in the previous notebook. Here, we will provide a more in-depth discussion.\nSince Python is an object-based language, it is important to be able to define different types of objects. Classes serve as blueprints for creating new types of objects. Thus, the concept, use, and application of classes is very important in Python.\nTo create a new class, you must use the class keyword. In the following example, you are generating a new class called Course. To construct a class, you must use the __init__() function. Within this function, you can assign values to object properties, and __init__() will be executed any time a new instance of the class is created. When You create an instance of my Course class, three properties will be initiated: the subject code, course number, and **course name*.\nself references the current instance of the class. Although you can use a term other than self, self is the standard term used. Regardless of the term used, it must be the first parameter in __init__().\nAfter the __init__() function, you then define a method that will be associated with the class. This method, printCourse(), will print the course name. Again, methods are functions that are associated with an object or class.\nIn order to use the method, You must first create an instance of the class and provide arguments for the required parameters. You can then apply the method to the instance to print the course info.\nOnce an instance of a class is created, the arguments assigned to properties can be changed using the following generic syntax: instance.property = new argument. Here you are changing the number parameter of the x instance of the Course class to 350. and then use my printCourse() method again.\nclass Course:\n    def __init__(self, subject, number, name):\n        self.subject = subject\n        self.number = number\n        self.name = name\n    def printCourse(self):\n        print(\"Course is \" + self.subject + \": \" + self.name + \" with the code: \" + str(self.number))\n\nx = Course(\"Spatial Analysys\", 33209, \"Using Python\")\nx.printCourse()\ntype(x)\n\nx.number = 350\nx.printCourse()\nOnce a class is created, subclassess can be derived from it. By default, subclasses will take on the properties and methods of the parent or superclass. However, you can alter or add properties and methods. This allows you to start with a more generic blueprint and refine it for a specific use case, as opposed to building a new class from scratch.\nIn the example below, I have redefined the Course class then subclassed it to create the Undergrad class. I have added a parameter, which requires redefining the __init__() function. The super() function returns all of the parameters and methods of the parent class. The use of super() provides control over what is inherited by the child class from the parent. We will not explore all possible use cases here. I then define a new method called printCourse2().\nOnce an instance of the Undergrad class is created, I can use both methods, since the printCourse() method was inherited from the parent class.\nclass Course:\n    def __init__(self, subject, number, name):\n        self.subject = subject\n        self.number = number\n        self.name = name\n    def printCourse(self):\n        print(\"Course is \" + self.subject + \" \" + self.name + \", Code:  \"+ str(self.number))\n\nclass Undergrad(Course):\n    def __init__(self, subject, number, name, level):\n        super().__init__(subject, number, name)\n        self.level = level\n    def printCourse2(self):\n       print(\"Undergrad Course is \" + self.subject + \" \"  + self.name + \". \" + \"Must be a \" + self.level + \" to take this course.\") \n\nx = Undergrad(\"Spatial Analysys\", 3209, \"With Python\", \"for New students\")\nx.printCourse()\nx.printCourse2()\nYou will not be required to created classes and subclasses in this course. However, it is important to understand this functionality of Python for making use of modules and libraries, as this is used extensively. For example, the PyTorch library, which is used for deep learning, makes extensive use of classes, and using it will require subclassing available classes."
  },
  {
    "objectID": "Lab_3.html#math-module",
    "href": "Lab_3.html#math-module",
    "title": "Lab No 3: Python Basics - Part 2",
    "section": "Math Module",
    "text": "Math Module\nThe functionality of Python is expanded using modules. Modules represent sets of code and tools and are combined into libraries. In this class, we will explore several modules or libraries used for data science including NumPy, Pandas, matplotlib, and scikit-learn. We will also explore libraries for geospatial data analysis including GeoPandas and Rasterio.\nAs an introduction to modules and libraries, we will now explore the math module. To use a module, it first needs to be imported. You can then use the methods provided by the module. When using a method from the math module, you must include the module name as demonstrated below.\nimport math\n\nx = 4.318\nprint(math.cos(x))\nprint(math.sin(x))\nprint(math.tan(x))\nprint(math.sqrt(x))\nprint(math.log10(x))\nprint(math.floor(x))\nYou can also provide an alias or shorthand name for the module when importing it by using the as keyword. This can be used to simplify code.\nimport math as m\n\nx = 4.318\nprint(m.cos(x))\nprint(m.sin(x))\nprint(m.tan(x))\nprint(m.sqrt(x))\nprint(m.log10(x))\nprint(m.floor(x))\nIf you want to import each individual function from a module and not need to use the module name or alias name in your code, you can use the import syntax demonstrated below. This is generally best to avoid, especially if the module is large and/or has many functions.\nfrom math import *\n\nx = 4.318\nprint(cos(x))\nprint(sin(x))\nprint(tan(x))\nprint(sqrt(x))\nprint(log10(x))\nprint(floor(x))\nYou can also import individual functions or subsets of functions as opposed to the entire module.\nfrom math import cos, sin\nx = 4.318\nprint(cos(x))\nprint(sin(x))"
  },
  {
    "objectID": "Lab_3.html#working-with-files",
    "href": "Lab_3.html#working-with-files",
    "title": "Lab No 3: Python Basics - Part 2",
    "section": "Working with Files",
    "text": "Working with Files\n\n1. Read Files\nAs a data scientist or geospatial data scientist, you need to use Python to work with and analyze files on your local machine.\nFirst, a file or folder path can be assigned to a variable. On a Windows machine, you will need to either:\n\nChange the backslashes to forward slashes or\nUse the backslash escape character ahead of any backslash.\n\nThis is tricky depending of the operating system.\ntxt1 = \"D:/data/text_files/t1.txt\" #Must change backslash to forward slash\ntxt1 = \"D:\\\\data\\\\text_files\\\\t1.txt\" #Or, use the backslash escape character\nFor the following instructions you need to upload certain datasets to your Cloud GIS. In case you are working locally, the workflow is similar, you need to provide the appropriate path. For now we will upload the data into you Cloud GIS, so you can read it using the notebook hosted in ArcGIS Online.\nIn this Notebook, click in Files.\n\nDownload the data folder from Moodle, then click in home, then click in Choose file and select cities.txt\n\nOnce you have chosen the file, then name will appear to confirm, now clic Upload.\n\nNow you have the cities.txt in your portal and now you can call the call., if you click in the plus symbol you will get a new cell from ArcGIS Notebook to help you to understand what is the correct way to call this dataset. For future instructions make your you have uploaded the required dataset, from Data folder included in Moodle.\nTo read a text file you can just use the module with, like this:\nwith open('/arcgis/home/cities.txt', \"r\") as f:\n    contents = f.read()\n    print(contents)\nIn the following example, we first import the csv module, which provides functionality for working with CSV files.\nWe then use the with statement to open the file ‚Äúworld_cities.csv‚Äù in read mode (r) and assign the file object to the variable csvfile.\nWe pass this file object to the csv.reader function to create a reader object that can be used to iterate over the rows of the CSV file.\nInside the with block, we loop over each row in the CSV file using a for loop, and print out each row using the print function.\nNote that each row is represented as a list of strings.\nNow, upload the world_cities.csv file, using the same process we described earlier.\nimport csv\n\nwith open('/arcgis/home/world_cities.csv', \"r\") as csvfile:\n    reader = csv.reader(csvfile)\n    for row in reader:\n        print(row)\nSpecific modules or libraries will allow you to read in and work with specific types of data. For example, in the code below you are using Pandas to read in a comma-separated values (CSV) file as a Pandas DataFrame. We will discuss Pandas in a later part of this module.\nIn case you did not notice we use the keyword import to literally import the functionally of an external package that requires previous installation. For now we can import it without any issue. In case you need to import a new module that has not been included in your initial setup, you can still install it first, then make the import.\nimport numpy as np #Import numpy package, but then we said as np just for quick reference later in the code.\nimport pandas as pd #Import pandas package, but then we said as pd just for quick reference later in the code.\n# Sometime get the rigth path is tricky, so before entering to the function, you can add a previous cell and make sure the path is correctly called.\ncities_df = pd.read_csv('/arcgis/home/world_cities.csv', sep=\",\", header=0, encoding=\"ISO-8859-1\")\ncities_df.head(10)\nYou can also use other modules like matplotlib to read and plot external files like an image, like this:\n# importing required libraries\nimport matplotlib.pyplot as plt\nimport matplotlib.image as img\n  \n# reading the image\ntestImage = img.imread('/arcgis/home/sentinel_img.png')\n  \n# displaying the image\nplt.imshow(testImage)\n\n\nWorking with Directories\nInstead of reading in individual files, you may want to access entire lists of files in a directory. The example below demonstrates one method for accomplishing this using the os module and list comprehension. Specifically, it will find all TXT files in a directory and write their names to a list.\nOnly the file name is included in the generated list, so I use additional list comprehension to add the full file path and generate a new list.\nimport os\n\ndirect = '/arcgis/home/text_files'\n\nfiles = os.listdir(direct)\nfiles_txt = [i for i in files if i.endswith('.txt')]\nprint(files_txt)\n\ntxtlst = [direct + s for s in files_txt]\nprint(txtlst)\nThe code below demonstrates three other methods for reading in a list of TXT files from a directory. The first method uses the listdir() method from the os module, the second uses the walk() method form the os module (which allows for recursive searching within subdirectories), and the last method uses the glob module.\nYou will see many other examples in this course of how to read files and lists of file names.\nfrom os import listdir\n \ndef list_files1(directory, extension):\n    return (f for f in listdir(directory) if f.endswith('.' + extension))\n\nfrom os import walk\n\ndef list_files2(directory, extension):\n    for (dirpath, dirnames, filenames) in walk(directory):\n        return (f for f in filenames if f.endswith('.' + extension))\n    \nfrom glob import glob\nfrom os import getcwd, chdir\n \ndef list_files3(directory, extension):\n    saved = getcwd()\n    chdir(directory)\n    it = glob('*.' + extension)\n    chdir(saved)\n    return it\n\ndirect = '/arcgis/home/text_files/'\nmethod1 = list(list_files1(direct, \"txt\"))\nmethod2 = list(list_files2(direct, \"txt\"))\nmethod3 = list_files3(direct, \"txt\")\nprint(method1)\nprint(method2)\nprint(method3)"
  },
  {
    "objectID": "Lab_3.html#f-strings",
    "href": "Lab_3.html#f-strings",
    "title": "Lab No 3: Python Basics - Part 2",
    "section": "f-Strings",
    "text": "f-Strings\nIn Python, f-strings can be used to format printed strings or include variables within strings. This technique can be useful for generating well-formatted and useful print statements or dynamically using variables in printed strings.\nIn the first example, I am printing x but with formatting defined to round to two decimal places. In the next example, I multiply x by itself in the printed string. Note that f-strings will begin with f followed by the statement in parenthesis. Variables or code will be placed in curly brackets, and formatting can be defined using syntax after a colon. In the first example, ‚Äú:2f‚Äù indicates to round to two decimal places.\nIn the third example, I am calling x in a statement while in the fourth example I am using the .upper() method to convert the string to all uppercase in the printed statement. Lastly, I have edited the enumerate() example above with an f-string to print the country name and assigned index in the for loop.\nThroughout this course, you will see examples of f-strings for providing better formatted and/or more interpretable print output.\nx = 0.123456789\nprint(f'The value is {x:.2f}')\nx = 6\nprint(f'{x} times 2 is equal to {x*x}')\nx = \"blue\"\nprint(f'My favorite color is {x}.')\nx = \"blue\"\nprint(f'My favorite color is {x.upper()}.')\n\ncountries = [\"Belgium\", \"Mexico\", \"Italy\", \"India\"]\nfor index, country in enumerate(countries):\n    print(f'The index for {country} is {index}.')"
  },
  {
    "objectID": "Lab_3.html#whats-next",
    "href": "Lab_3.html#whats-next",
    "title": "Lab No 3: Python Basics - Part 2",
    "section": "What‚Äôs next",
    "text": "What‚Äôs next\nWith these two notebooks(Part No1, and Part No2) you got a comprehensive list of components that you now can use to write python code. Now it is just a matter of practice and more practice.\nInitially you will think this is extremely complicated or long, but with the exercises you will realised that is actually pretty simple.\nLike I said before, if you have any particular question aks the available TA in the room.\nWell done, now you have covered the basics for python it is time to PRACTICE a bit with less guidance.\nOpen the Exercises_PythonBasics and complete all the challenges there."
  },
  {
    "objectID": "DataSources.html#scottish-spatial-data-infrastructure-ssdi",
    "href": "DataSources.html#scottish-spatial-data-infrastructure-ssdi",
    "title": "Data Sources",
    "section": "1. Scottish Spatial Data Infrastructure (SSDI)",
    "text": "1. Scottish Spatial Data Infrastructure (SSDI)\nThe official portal for discovering and accessing spatial datasets from Scottish public bodies.\nData Available: - Administrative boundaries - Environmental and natural heritage data - Planning and infrastructure - Marine and coastal datasets - Data formats: Shapefiles, GeoJSON, WMS, WFS"
  },
  {
    "objectID": "DataSources.html#scotlands-environment-web",
    "href": "DataSources.html#scotlands-environment-web",
    "title": "Data Sources",
    "section": "2. Scotland‚Äôs Environment Web",
    "text": "2. Scotland‚Äôs Environment Web\nA partnership platform providing environmental datasets and interactive maps.\nData Available: - Land cover and land use - Air and water quality - Biodiversity and habitats - Climate and emissions - Tools: Map viewers, WMS services, downloadable shapefiles"
  },
  {
    "objectID": "DataSources.html#spatial-hub-improvement-service",
    "href": "DataSources.html#spatial-hub-improvement-service",
    "title": "Data Sources",
    "section": "3. Spatial Hub (Improvement Service)",
    "text": "3. Spatial Hub (Improvement Service)\nAggregates and publishes spatial data provided by all 32 Scottish local authorities.\nData Available: - Planning applications - Housing land audits - School catchments - Local development plans - Data formats: Shapefiles, WMS, GeoJSON (registration may be required)"
  },
  {
    "objectID": "DataSources.html#uk-government-data-portal-data.gov.uk",
    "href": "DataSources.html#uk-government-data-portal-data.gov.uk",
    "title": "Data Sources",
    "section": "4. UK Government Data Portal (data.gov.uk)",
    "text": "4. UK Government Data Portal (data.gov.uk)\nThe central open data portal for the UK government.\nData Available: - Transport networks - Health and social care - Demographics and census - Crime and safety - Environment and energy - Formats: CSV, GeoJSON, Shapefiles, APIs, WMS/WFS services"
  },
  {
    "objectID": "DataSources.html#ordnance-survey-opendata",
    "href": "DataSources.html#ordnance-survey-opendata",
    "title": "Data Sources",
    "section": "5. Ordnance Survey OpenData",
    "text": "5. Ordnance Survey OpenData\nThe UK‚Äôs national mapping agency providing a range of open and premium geographic datasets.\nData Available: - OpenMap Local (general-purpose vector mapping) - OS Open Roads, OS Open Rivers - Boundary-Line (administrative boundaries) - Access via: Downloads, APIs, and ArcGIS-ready formats"
  },
  {
    "objectID": "DataSources.html#national-records-of-scotland-nrs-geography",
    "href": "DataSources.html#national-records-of-scotland-nrs-geography",
    "title": "Data Sources",
    "section": "6. National Records of Scotland (NRS) Geography",
    "text": "6. National Records of Scotland (NRS) Geography\nProvides the official statistical geographies for Scotland.\nData Available: - Data zones and Intermediate Zones - Census output areas - Health boards, local authorities - Formats: Shapefiles, GeoJSON"
  },
  {
    "objectID": "DataSources.html#office-for-national-statistics-ons-geography",
    "href": "DataSources.html#office-for-national-statistics-ons-geography",
    "title": "Data Sources",
    "section": "7. Office for National Statistics (ONS) Geography",
    "text": "7. Office for National Statistics (ONS) Geography\nGeospatial portal from the ONS offering boundary data and census geography.\nData Available: - Statistical geographies (LSOA, MSOA) - Census 2011 and 2021 boundaries - Parliamentary constituencies - Downloadable in ESRI Shapefile and GeoPackage formats"
  },
  {
    "objectID": "DataSources.html#defra-data-services-platform",
    "href": "DataSources.html#defra-data-services-platform",
    "title": "Data Sources",
    "section": "8. DEFRA Data Services Platform",
    "text": "8. DEFRA Data Services Platform\nUK Government‚Äôs portal for environment-related data and services.\nData Available: - Flood risk zones - Agricultural land classification - River networks and water quality - Waste and recycling facilities - Access via: Shapefiles, APIs, WMS/WFS"
  },
  {
    "objectID": "DataSources.html#openstreetmap-geofabrik-uk-extracts",
    "href": "DataSources.html#openstreetmap-geofabrik-uk-extracts",
    "title": "Data Sources",
    "section": "9. OpenStreetMap (Geofabrik UK Extracts)",
    "text": "9. OpenStreetMap (Geofabrik UK Extracts)\nExtracts from OpenStreetMap for Great Britain, including Scotland.\nData Available: - Buildings, highways, land use, points of interest - Routable and editable map data - Formats: .osm.pbf, shapefiles (via tools like osmconvert or QGIS plugins)"
  },
  {
    "objectID": "DataSources.html#edinburgh-geoportal",
    "href": "DataSources.html#edinburgh-geoportal",
    "title": "Data Sources",
    "section": "10. Edinburgh GeoPortal",
    "text": "10. Edinburgh GeoPortal\nA geospatial data repository from Edinburgh with open datasets.\nData Available: - Local and global environmental data - Terrain and elevation - Land cover and vegetation indexes - Datasets relevant for climate change, ecology, and earth observation"
  },
  {
    "objectID": "DataSources.html#glasgow-geoportal",
    "href": "DataSources.html#glasgow-geoportal",
    "title": "Data Sources",
    "section": "11. Glasgow GeoPortal",
    "text": "11. Glasgow GeoPortal\nA geospatial data repository from Glasgow with open datasets.\nData Available: - Local and global environmental data - Terrain and elevation - Land cover and vegetation indexes - Datasets relevant for climate change, ecology, and earth observation"
  },
  {
    "objectID": "DataSources.html#arcgis-living-atlas-uk-content",
    "href": "DataSources.html#arcgis-living-atlas-uk-content",
    "title": "Data Sources",
    "section": "12. ArcGIS Living Atlas (UK content)",
    "text": "12. ArcGIS Living Atlas (UK content)\nESRI‚Äôs curated collection of geographic information, including UK-specific content.\nData Available: - Demographics, base maps, boundaries - Real-time environmental data - Accessible directly from ArcGIS Online for instant use"
  },
  {
    "objectID": "DataSources.html#arcgis-living-atlas-uk-content-1",
    "href": "DataSources.html#arcgis-living-atlas-uk-content-1",
    "title": "Data Sources",
    "section": "13. ArcGIS Living Atlas (UK content)",
    "text": "13. ArcGIS Living Atlas (UK content)\nESRI‚Äôs curated collection of geographic information, including UK-specific content.\nData Available: - Demographics, base maps, boundaries - Real-time environmental data - Accessible directly from ArcGIS Online for instant use"
  },
  {
    "objectID": "DataSources.html#urban-big-data-centre",
    "href": "DataSources.html#urban-big-data-centre",
    "title": "Data Sources",
    "section": "14. Urban Big Data Centre",
    "text": "14. Urban Big Data Centre\nUrban Big Data Centre is a dynamic national research hub and data service, championing the use of smart data to inform policymaking and enhance the quality of urban life.\nData Available: - Transport and Mobility, Housing and property, Labor Market, Environment."
  },
  {
    "objectID": "DataSources.html#tips-for-students",
    "href": "DataSources.html#tips-for-students",
    "title": "Data Sources",
    "section": "Tips for students",
    "text": "Tips for students\n\nMany of these platforms offer shapefiles, WMS or ArcGIS REST endpoints, which can be added directly to your ArcGIS Online web map.\nMake sure to always cite the data source in your apps or reports.\nFor reproducibility, record the download date and dataset version.\nUse filtering and geoprocessing tools in ArcGIS Online to tailor data to your study area."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. ‚ÄúLiterate Programming.‚Äù Comput.\nJ. 27 (2): 97‚Äì111. https://doi.org/10.1093/comjnl/27.2.97."
  }
]